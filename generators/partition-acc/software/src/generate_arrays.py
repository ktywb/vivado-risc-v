import sys
import os

ALIGNMENT = 64

def hex_file_to_c_array(filename, var_name):
    """
    Converts a hex file to a C uint8_t array definition,
    preserving the byte order within each line (treating input as big-endian).
    """
    processed_hex_content = ""
    try:
        with open(filename, 'r') as f:
            for line_num, line in enumerate(f, 1):
                line_hex = line.strip()
                if not line_hex: # Skip empty lines
                    continue
                if len(line_hex) % 2 != 0:
                    print(f"Error: Line {line_num} in {filename} has an odd number of hex characters: '{line_hex}'", file=sys.stderr)
                    return None, 0

                # Extract bytes (pairs of hex chars) from the line
                line_bytes_hex = [line_hex[i:i+2] for i in range(0, len(line_hex), 2)]
                # --- Removed byte reversal ---
                line_bytes_hex.reverse()
                # Append the bytes for this line to the total content in their original order
                processed_hex_content += "".join(line_bytes_hex)

    except FileNotFoundError:
        print(f"Error: File not found: {filename}", file=sys.stderr)
        return None, 0
    except Exception as e:
        print(f"Error reading or processing file {filename}: {e}", file=sys.stderr)
        return None, 0

    # Now process the combined hex string (bytes in original order)
    byte_values = []
    try:
        if len(processed_hex_content) % 2 != 0:
             # This should ideally not happen if line checks work, but good failsafe
            print(f"Error: Total processed hex content for {filename} has an odd number of characters.", file=sys.stderr)
            return None, 0

        for i in range(0, len(processed_hex_content), 2):
            byte_str = processed_hex_content[i:i+2]
            byte_values.append(int(byte_str, 16))
    except ValueError as e:
        print(f"Error converting hex in {filename}: {e}", file=sys.stderr)
        return None, 0

    # C array generation remains largely the same
    c_code = f"// Data from {filename}, byte order preserved per line (Big-Endian)\n" # Updated comment
    c_code += f"uint8_t {var_name}[] __attribute__((aligned({ALIGNMENT}))) = {{\n  "
    for i, byte in enumerate(byte_values):
        c_code += f"0x{byte:02X}, "
        if (i + 1) % 16 == 0 and i != len(byte_values) - 1:
            c_code += "\n  "
    c_code += "\n};\n"
    # Use the actual size of the generated byte array
    c_code += f"size_t {var_name}_size = sizeof({var_name});\n"

    return c_code, len(byte_values)

# ... rest of the script remains the same ...
if __name__ == "__main__":
    data_dir = "../data" # Adjust if script is run from a different location
    output_filename = "partition_data.h" # Or print to stdout

    output_code = f"// Generated data arrays\n// Byte order preserved per line from original .mem files (Big-Endian)\n" # Updated comment
    output_code += f"#include <stddef.h>\n#include <stdint.h>\n\n#define ALIGNMENT {ALIGNMENT}\n\n"
    total_bytes = 0

    files_to_process = {
        "cache_line.mem": "cache_line_data",
        "tuple_length.mem": "tuple_length_data",
        "key.mem": "key_info_data"
    }

    for mem_file, var_name in files_to_process.items():
        filepath = os.path.join(data_dir, mem_file)
        print(f"Processing {filepath} (preserving byte order per line)...") # Updated message
        array_code, byte_count = hex_file_to_c_array(filepath, var_name)
        if array_code:
            output_code += array_code + "\n"
            total_bytes += byte_count
            print(f"  -> Generated {var_name}[{byte_count}]")
        else:
            print(f"Error processing {filepath}. Exiting.", file=sys.stderr)
            sys.exit(1) # Exit if conversion failed

    # Write to header file or print
    try:
        with open(output_filename, 'w') as f:
             f.write(output_code)
        print(f"\nGenerated C header '{output_filename}' with {total_bytes} total bytes.")
    except IOError as e:
        print(f"Error writing to output file {output_filename}: {e}", file=sys.stderr)
        sys.exit(1)

    # Alternatively, print to stdout:
    # print(output_code)